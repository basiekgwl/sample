package mybatis.controller;

import hello.AccountType;
import mybatis.dao.UserEntity;
import mybatis.dao.UserAccounts;
import lombok.extern.slf4j.Slf4j;
import mybatis.dao.UserDao;
import mybatis.error.handler.OperationException;
import mybatis.error.handler.UserDataNotFoundException;
import mybatis.mapper.EmployeeDBMapper;
import mybatis.services.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.ui.ModelMap;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.MissingServletRequestParameterException;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.validation.ConstraintViolation;
import javax.validation.ConstraintViolationException;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import java.math.BigDecimal;
import java.util.List;
import java.util.Set;

import static mybatis.services.ICustomJsonResponses.getJsonResponseForInsert;
import static mybatis.services.ICustomJsonResponses.getModelAndView;

@Slf4j
@Validated
@RestController   // This means that this class is a Controller
@RequestMapping(path = "/user") // This means URL's start with /demo (after Application path)
public class UserController extends AbstractController {

    public static final String MSG_IF_NULL = " !!!!!!!!!!!!!!  NULL  !!!!!!!!!!!!!!!!";
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private EmployeeDBMapper employeeDBMapper;

    UserDao userDao = new UserDao();

    @GetMapping(path = "/find")
    public @ResponseBody
    UserEntity getOneUser(@RequestParam Long userId) {

        UserEntity byId = employeeDBMapper.findById(userId);
        log.info("Get data: " + byId);
        return byId;
    }

    @GetMapping(path = "/getUserByName")
    public @ResponseBody
    List<UserEntity> getUserByName(@RequestParam String fullName) {

        List<UserEntity> results = employeeDBMapper.findByUserFullName(fullName);
        for (UserEntity item : results) {
            log.debug("UserData: " + item.getUserFullName() + " -- address: " + item.getUserAddress());
        }
        return results;
    }

    @GetMapping(path = "/insertUser")
    public @ResponseBody
    String addNewUser(@Size(max = IFieldsSize.USER_NAME_MAX_SIZE, message = IErrorMsg.INVALID_FULL_NAME_SIZE) @RequestParam String fullName,
                      @Size(min = IFieldsSize.USER_NIP_SIZE, max = IFieldsSize.USER_NIP_SIZE, message = IErrorMsg.INVALID_NIP_SIZE) @RequestParam String userNip,
                      @Size(min = IFieldsSize.USER_PESEL_SIZE, max = IFieldsSize.USER_PESEL_SIZE, message = IErrorMsg.INVALID_PESEL_SIZE) @RequestParam String userPesel,
                      @Size(max = IFieldsSize.USER_ADDRESS_MAX_SIZE, message = IErrorMsg.INVALID_ADDRESS_SIZE) @RequestParam String address,
                      @Size(max = IFieldsSize.USER_CITY_MAX_SIZE, message = IErrorMsg.INVALID_CITY_SIZE) @RequestParam String city) {


        UserEntity myUserEntity = UserEntity.builder()
                .userFullName(fullName)
                .userNip(userNip)
                .userPesel(userPesel)
                .userAddress(address)
                .city(city)
                .build();

        userDao.save(myUserEntity);

        return IUserMsg.INSERT_USER_SUCCESS + myUserEntity.getUserId();
    }

    @GetMapping(path = "/updateUser")
    public @ResponseBody
    String updateUserData(@RequestParam Long userId,
                          @RequestParam String fullName,
                          @RequestParam String userNip,
                          @RequestParam String userPesel,
                          @RequestParam String address,
                          @RequestParam String city) {

        UserEntity myUserEntity = new UserEntity(userId, fullName, userNip, userPesel, address, city);
        userDao.update(myUserEntity);
        return "UserEntity was updated successfully!!!";
    }


    @GetMapping(path = "/userAccounts")
    public @ResponseBody
    List<UserAccounts> getUserAccounts(@RequestParam Long userId) {
        return employeeDBMapper.findAccountsByUserId(userId);
    }

    @GetMapping(path = "/getAllAccounts")
    public @ResponseBody
    List<UserAccounts> getAllAccounts() {
        return employeeDBMapper.getAllAccounts();
    }

    @GetMapping(path = "/getAccountByNrb")
    public @ResponseBody
    UserAccounts getAccountData(@RequestParam String nrb) {
        return employeeDBMapper.getAccountByNumber(nrb);
    }

    @GetMapping(path = "/insertNrbForUser")
    public @ResponseBody
    long insertNrbData(@RequestParam int id,
                       @RequestParam String nrb,
                       @RequestParam AccountType type,
                       @RequestParam BigDecimal balance) {

        UserAccounts accountData = new UserAccounts(id, type, nrb, balance);
        employeeDBMapper.insertAccountData(accountData);

        return accountData.getAccountId();

    }

    @GetMapping(path = "/insertNrb")
    public @ResponseBody
    ModelMap insertNrb(@RequestParam int userId,
                       @RequestParam AccountType type,
                       @RequestParam String nrb,
                       @RequestParam BigDecimal balance) {

        UserAccounts accountData = new UserAccounts(userId, type, nrb, balance);
        long result = employeeDBMapper.insertNewAccount(accountData);
        if (result != 1) {
            log.error("Insert failed!");
            throw new OperationException();
        }
        return getJsonResponseForInsert(accountData);
    }

    @RequestMapping(method = RequestMethod.GET, path = "/getAccountsForUser")
    public @ResponseBody
    UserEntity getAccountsForUserById(@RequestParam("userId") @NotNull Long userId) {

        log.info("PRE userId: " + userId);

        UserEntity userEntityData = employeeDBMapper.getAllAccountsForUserById(userId);

        if (userEntityData == null) {
            log.debug(MSG_IF_NULL);
            throw new UserDataNotFoundException();
        }

        log.info("Data: " + userEntityData);
        log.info("AccountsData: " + userEntityData.getUserAccounts());
        return userEntityData;
    }

    @GetMapping(path = "/getOneAccountAndUserData")
    public @ResponseBody
    UserAccounts getOneAccountAndUserData(@Size(min = IFieldsSize.ACCOUNT_NRB_SIZE, max = IFieldsSize.ACCOUNT_NRB_SIZE, message = IErrorMsg.INVALID_NBR_SIZE)
                                          @RequestParam String accountNrb) {

        UserAccounts userAccount = employeeDBMapper.getAccountAndUserData(accountNrb);
        if (userAccount == null) {

            log.error(MSG_IF_NULL);
            throw new UserDataNotFoundException();
        }
        return userAccount;
    }


    @GetMapping(path = "/getAccountsForUser2")
    public @ResponseBody
    UserEntity getMyAllUsers(@RequestParam long userId) {
        UserEntity userEntityData = employeeDBMapper.getMyAllUsers(userId);
        if (userEntityData == null) {
            log.debug(MSG_IF_NULL);
            throw new UserDataNotFoundException();
        }
        log.info("AccountsData: " + userEntityData.getUserAccounts());
        return userEntityData;
    }

    @Override
    public ModelMap handleTypeMismatch(HttpServletRequest req, MethodArgumentTypeMismatchException ex) {
        return super.handleTypeMismatch(req, ex);
    }

    @Override
    public ModelMap handleMissingParam(HttpServletRequest req, MissingServletRequestParameterException ex) {
        return super.handleMissingParam(req, ex);
    }

    @Override
    public ModelMap handleBadRequests(HttpServletRequest req, ConstraintViolationException ex) {
        return super.handleBadRequests(req, ex);
    }

    @Override
    public void conflict() {
        super.conflict();
    }

}

package mybatis.controller;

import hello.AccountType;
import lombok.extern.slf4j.Slf4j;
import mybatis.dao.UserAccounts;
import mybatis.dao.UserDao;
import mybatis.dao.UserEntity;
import mybatis.error.handler.OperationException;
import mybatis.error.handler.UserDataNotFoundException;
import mybatis.mapper.EmployeeDBMapper;
import mybatis.services.IErrorMsg;
import mybatis.services.IFieldsSize;
import mybatis.services.IUserMsg;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.ui.ModelMap;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.MissingServletRequestParameterException;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import javax.servlet.http.HttpServletRequest;
import javax.validation.ConstraintViolationException;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import java.math.BigDecimal;
import java.util.List;

import static mybatis.services.ICustomJsonResponses.getJsonResponseForInsert;

@Slf4j
@RestController
@Validated // This means that this class is a Controller
public class UserController extends AbstractController implements IUserController, IAccountController {

    public static final String MSG_IF_NULL = " !!!!!!!!!!!!!!  NULL  !!!!!!!!!!!!!!!!";


    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private EmployeeDBMapper employeeDBMapper;

    UserDao userDao = new UserDao();

    public UserEntity getOneUser(Long userId) {

        UserEntity byId = employeeDBMapper.findById(userId);
        log.info("Get data: " + byId);
        return byId;
    }

    public List<UserEntity> getUserByName(String fullName) {

        List<UserEntity> results = employeeDBMapper.findByUserFullName(fullName);
        for (UserEntity item : results) {
            log.debug("UserData: " + item.getUserFullName() + " -- address: " + item.getUserAddress());
        }
        return results;
    }

    public String addNewUser(String fullName, String userNip, String userPesel, String address, String city) {

        UserEntity myUserEntity = UserEntity.builder()
                .userFullName(fullName)
                .userNip(userNip)
                .userPesel(userPesel)
                .userAddress(address)
                .city(city)
                .build();

        userDao.save(myUserEntity);
        return IUserMsg.INSERT_USER_SUCCESS + myUserEntity.getUserId();
    }

    public String updateUserData(Long userId, String fullName, String userNip, String userPesel, String address, String city) {

        UserEntity myUserEntity = new UserEntity(userId, fullName, userNip, userPesel, address, city);
        userDao.update(myUserEntity);
        return "UserEntity was updated successfully!!!";
    }


    public List<UserAccounts> getUserAccounts(Long userId) {
        return employeeDBMapper.findAccountsByUserId(userId);
    }

    public List<UserAccounts> getAllAccounts() {
        return employeeDBMapper.getAllAccounts();
    }


    public UserAccounts getAccountData(String nrb) {
        return employeeDBMapper.getAccountByNumber(nrb);
    }

    public long insertNrbData(int id, String nrb, AccountType type, BigDecimal balance) {

        UserAccounts accountData = new UserAccounts(id, type, nrb, balance);
        employeeDBMapper.insertAccountData(accountData);
        return accountData.getAccountId();
    }

    public ModelMap insertNrb(int userId, AccountType type, String nrb, BigDecimal balance) {

        UserAccounts accountData = new UserAccounts(userId, type, nrb, balance);
        long result = employeeDBMapper.insertNewAccount(accountData);
        if (result != 1) {
            log.error("Insert failed!");
            throw new OperationException();
        }
        return getJsonResponseForInsert(accountData);
    }
    
    public @ResponseBody
    UserEntity getAccountsForUserById(@RequestParam("userId") @NotNull Long userId) {

        log.info("PRE userId: " + userId);

        UserEntity userEntityData = employeeDBMapper.getAllAccountsForUserById(userId);

        if (userEntityData == null) {
            log.debug(MSG_IF_NULL);
            throw new UserDataNotFoundException();
        }

        log.info("Data: " + userEntityData);
        log.info("AccountsData: " + userEntityData.getUserAccounts());
        return userEntityData;
    }

    @GetMapping(path = "/getOneAccountAndUserData")
    public @ResponseBody
    UserAccounts getOneAccountAndUserData(@Size(min = IFieldsSize.ACCOUNT_NRB_SIZE, max = IFieldsSize.ACCOUNT_NRB_SIZE, message = IErrorMsg.INVALID_NBR_SIZE)
                                          @RequestParam String accountNrb) {

        UserAccounts userAccount = employeeDBMapper.getAccountAndUserData(accountNrb);
        if (userAccount == null) {

            log.error(MSG_IF_NULL);
            throw new UserDataNotFoundException();
        }
        return userAccount;
    }


    @GetMapping(path = "/getAccountsForUser2")
    public @ResponseBody
    UserEntity getMyAllUsers(@RequestParam long userId) {
        UserEntity userEntityData = employeeDBMapper.getMyAllUsers(userId);
        if (userEntityData == null) {
            log.debug(MSG_IF_NULL);
            throw new UserDataNotFoundException();
        }
        log.info("AccountsData: " + userEntityData.getUserAccounts());
        return userEntityData;
    }

    @Override
    public ModelMap handleTypeMismatch(HttpServletRequest req, MethodArgumentTypeMismatchException ex) {
        return super.handleTypeMismatch(req, ex);
    }

    @Override
    public ModelMap handleMissingParam(HttpServletRequest req, MissingServletRequestParameterException ex) {
        return super.handleMissingParam(req, ex);
    }

    @Override
    public ModelMap handleBadRequests(HttpServletRequest req, ConstraintViolationException ex) {
        return super.handleBadRequests(req, ex);
    }

    @Override
    public void conflict() {
        super.conflict();
    }

}
